! in cv2macos_Jan252014
!
ver all no
!-------------------------------------------------------------------------------
!2345678911234567892123456789312345678941234567895123456789612345678971234567898
!
!             cv2macos_Sep302013.seq - Code V Macro [Macro-PLUS language]
!
!             (TEST VERSION - FOR EVALUATION PURPOSES ONLY)
!
!
!  Function:  Generates a Preliminary MACOS input file using Code V.
!
!  Usage:     First, start Code V and open target lens file for conversion.
!
!             (If using a Code V lens file that is already open, make sure any
!             desired changes have been saved before running this macro.)cv2macos_Sep252013
!
!             Then, type "in cv2macos2013" at command prompt (if in macro directory)
!             and enter the four input numbers (integers)
!
!        IN CV2MACOS_Jan252014 [GLOBAL SURFACE #]  [ZOOM POSITION] [FIELD NUMBER]  [WAVELENGTH NUMBER] [file name]
!
!  Inputs:    1. Global Surface Number
!             2. Zoom Position Number
!             3. Field Number
!             4. Wavelength Number
!             5. Output file name
!
!  Output:	  macosfile.in  (default)
!
!  Notes:
!  0.  Surface I-1 is assumed to be the exit pupil.  It must be curved with center of curvature on FPA.
!      Surface I-2 is assumed to be coincident with surface I, the image.
!      These surfaces must be hard coded into the CODE V model.
!
!      Dummy surfaces are ignored except for surfaces I-2, I-1, and I.
!
!  1.  IMPORTANT:  The object is currently assumed to be along the z-axis and
!      light traveling in the positive z-direction.

!  1B. The imager surface in the CODE V model is assumed to have no tilt/decenter.
!
!  2.  The macro should not overwrite an existing "macosfile.in" file.
!      Code V prompts for overwrite, append or new version # to avoid this.
!
!  3.  REVIEW AND MODIFY THE GENERATED .in FILE AS REQUIRED FOR THE SPECIFIC
!      APPLICATION.  Code V and MACOS have many capabilities not incorporated
!      in this macro.  This macro is intended to quickly generate a baseline
!      MACOS prescription of optical system components in global coordinates.
!      This eliminates the uninspiring task of entering vertex points and
!      psiElt's for each surface.
!
!  4.  Please refer to the "MACOS Manual" (JPL) for the many considerations
!      involved in generating a proper MAC0S .in file.
!
!  5.  THE USER MUST DEFINE AN OBSCURING SURFACE AT THE STOP LOCATION TO ACT
!      AS A PHYSICAL STOP.
!
!      The conversion macro does not do this, and it is especially important
!      for off-axis field angles.
!
!      Two (2) approaches to this issue are given below:
!
!      - If the stop is a unique surface, then change the stop surface EltType
!        to EltType= 9 (an obscuring surface) and define the stop diameter
!        as described in the MAC0S Manual.
!
!      - If the stop is defined by the clear aperture of an optical element,
!          then it is generally easiest to model the stop by adding a new,
!          separate obscuring surface (EltType= 9), located infinitesimally
!          ahead of the limiting clear aperture surface, with the same shape
!          as the optical element.  Define the aperture of the new surface in
!          accordance with the limiting clear aperture.
!
!      Then, in either case, increase the "Aperture" parameter in the MACOS .in
!      file to define an oversized grid of rays so that the stop, not the ray
!      bundle, limits off-axis throughput.  Set obs to 1 in MACOS to see
!      aperture/obscuration effects.
!
!  7.  FOR DIFFRACTION PROPAGATION YOU MUST ADD AND OPTIMIZE RETURN SURFACES
!      AS DESCRIBED IN THE MACOS MANUAL UNDER THE FEX AND ORS COMMANDS.
!      ALSO, MODIFY THE APERTURE SIZE AND NGRIDPTS, AS DICTATED BY PUPIL AND
!      IMAGE SAMPLING REQUIREMENTS.
!
!  8.  This program incorporates common default parameters to reduce
!      repetitive user interactions.  CHECK THE FOLLOWING DEFAULTS FOR
!      AGREEMENT WITH THE SUBJECT OPTICAL SYSTEM.
!
!      a) DEFAULTS UNDER 'DEFAULT MACOS CONSTANTS':
!
!         - extinction coefficients = 0.
!         - flux = 1.000.
!         - GridType = 1. (annular)
!         - Obscuration = 0.
!         - nGridpts = 31.
!         - PropType = 1.
!         - nECoord = 6.   ! new on 9/17/13
!
!      b) OTHER DEFAULT MACOS PARAMETERS:
!
!         - STOp surface defined as global origin.
!         - ChfRayDir taken @CodeV object surface (l,m,n).
!         - For the puroposes of this macro, finite conjugate is defined
!           defined as an object distance less than 1.0e+10 units.
!         - For FINITE conjugate systems:
!             ChfRayPos placed half the object distance BEFORE
!             the first surface (even for virtual objects).
!         - For INFINITE conjugate systems:
!             ChfRayPos located @100 units ahead of surface 1.
!         - Aperture = Code V EPD.
!         - xGrid = (1,0,0)
!         - yGrid = (0,1,0)
!         - Code V rdy = 0 converted to flat surface
!
!  9. MACOS surface types converted:
!
!     - reflective flats
!     - reflective surfaces including conics
!     - refractive surfaces including conics
!     - reference surfaces
!     - focal plane
!     - 10th order (D term) aspheric coefficients.
!         An error message indicates that higher order coefficients (if any)
!         must be added.
!     - Y-toroid surfaces modelled as an asphere.
!
!  10. THIS MACRO RESTORES THE LENS FILE AS THE LAST STEP, SO BE AWARE THAT ANY
!      CHANGES TO THE CODE V LENS FILE MADE SINCE THE LAST SAVE WILL BE LOST.
!      SAVE THE CODE V FILE BEFORE RUNNING THE MACRO IF DESIRED CHANGES HAVE
!      BEEN MADE.
!
!  11. Suggested modifications:
!      - Default lens file save at start.  (Notify or prompt before saving?)
!      - Change to [Element, Surface] from [EltType] variables.
!      - PropType to text variable.
!      - May be able to use GSC for tOut instead of dec calcs.
!      - Do not set RptElt to VptElt.
!
!  12. Check:
!      - Does Zernike coefficient sign change for concave vs. convex radius?
!
!  Written by:  Hiroshi Kadogawa
!  	          Jet Propulsion Laboratory
!  	          Pasadena, CA 91109
!  	          hiroshi@mail.jpl.nasa.gov
!
!  Revisions:
!
!  Date       By Modification
!  ---------- -- ------------
!  08/02/1993 HK Created.
!  02/18/1994 HK Added ChfRayPos for general object location.
!  04/05/1994 HK Added 10th order aspheric reflector and refractor.
!  04/26/1994 HK Convert Code V rdy = 0 to flat surface.
!	           Read object index of refraction, include in l,m,n
!                calculation
!  02/06/1997 SB Add preliminary capability to convert Apertures and
!                Obscurations (Currently not activated.)
!  08/00/2003 SB Kc, Kr implemented (instead of f, e)
!                Macos "Element" and "Surface" variables now used.
!  03/27/2006 HK Changed macro name to cv2macos.in
!                Changed output file to macosfile.in
!                Changed references from COMP to MACOS.
!                Zernike reflector, refractor.
!                 (x,y,l,pMon method not verified yet)
!                Set default to: ZernType = Noll, 45 terms max.
!  04/03/2006 HK EltName == 'SLB'.
!  04/05/2006 HK Added commented out REFR conic EltType == 8.
!  04/10/2006 HK Switched x, yMon definitions.  Changed sign of yMon unit vector.
!  04/14/2006 HK Change sign xMon component.  Exponential output format -> 2e.15e.
!
!  7/15/2013 JMR added comments; edited out the final RESTORE
!
!  9/17-25/2013 JMR Various additions for infinite object case, including
!                   Source distance 1E22
!                   RptElt as the x,y,z intersection point of field 1, zoom 1 with the surface
!                   Suppress printout of dummy surfaces.
!                   Add 6x6 matrix with axes same as the parent surface but centered on RptElt.
!                   Add notes and annotations.
!
!  10/1/2013 JMR    For Tout, when tilted surface is added in front of image plane, untilt the image plane.
!
!  10/20/2013 JMR   xObs must be multiplied by -1 if the aperture is rectangular.
!
!  1/25/2014 JMR    After weeks of intermittent testing on how to best handle xObs, we worked it down to these conclusions:
!                   depending on whether the surface is concave or convex, and whether the number of
!                   reflections PRIOR to the element is even or odd:
!                      Even + convex:  YES negate xObs
!                      Even and flat:  YES
!                      Even and concave:  NO
!                      Odd and convex: NO
!                      Odd and flat:  YES
!                      Odd and concave: YES
!                   Or equivalently, YES if curvature is >0 or = 0; NO if curvature is < 0.
!                   So we will un-do the change of 10/20/2013 and insert the correct checks.
!                   We compute ^xobs_scale at the start of the FOR loop through the surfaces,
!                   and multiply the direction cosines (xobs) by it.
!
! 1/25/2014 JMR     Add a 5th input field to allow the user to input preferred file name (must be in single quotes).
!                   The default is still macosfile.in
!----------------------------------------------------------------------------------------------------------------------------
!
! VARIABLE DECLARATIONS
!
chk yes		! enforce explicit declaration
lcl str ^format1  ^format2a ^format2   ^format3  ^format4  ^format5
lcl str ^format6  ^format7  ^format8   ^format9  ^format10
lcl str ^format11 ^format12 ^format13  ^format14 ^format15
lcl str ^format16 ^format17 ^format18  ^format19 ^format19a ^format20
lcl str ^format21 ^format21a ^format22 ^format22b ^format22a ^format23
lcl str ^format24 ^format25
lcl str ^format26 ^format27 ^format28  ^format29 ^format30
lcl str ^format31 ^format32
lcl str ^format33 ^format34 ^format35                       ! Zernike listings
lcl str ^format36 ^format37 ^format38 ^format39 ^format40   ! p,x,y,z,l Mon
lcl str ^format41  ! local axes direction cosines for 6x6 matrix
lcl str ^slabel
lcl num ^a_flat_surf ^an_index_match ^a_vacuum		      ! Boolean variables
lcl num ^zero ^infinity ^pi
lcl num ^s ^global_sur ^zoom_pos ^field_pos ^wave_pos
lcl num ^obj_index
lcl num ^z_source ^ext_coef ^wavelength ^flux ^gridtype ^aperture
lcl num ^obscuration ^ngridpts ^previous_n ^current_n ^conic_const
lcl num ^l_chief ^m_chief ^n_chief ^x_chief ^y_chief ^z_chief
lcl num ^x_so ^y_so ^z_so ^x_s1 ^y_s1 ^z_s1
lcl num ^a_sur ^b_sur ^c_sur ^d_sur
lcl num ^x_sur ^y_sur ^z_sur ^l_sur ^m_sur ^n_sur
lcl num ^x_RptElt ^y_RptElt ^z_RptElt  ! new on 9/17/13
lcl num ^num_sur
lcl num ^initial_x ^final_x ^lsc_x ^lsc_y
lcl num ^initial_y ^final_y ^msc_x ^msc_y
lcl num ^initial_z ^final_z ^nsc_x ^nsc_y
lcl num ^elt_type ^Kr_elt ^prop_type ^n_ecoord
lcl num ^ape_type ^ape_1 ^ape_2 ^ape_3 ^ape_4
lcl num ^obs_type ^obs_1 ^obs_2 ^obs_3 ^obs_4
lcl num ^n ^m                 ! Counters
lcl num ^z(1..45)             ! Zernike Coefficient Array
lcl num ^ascr ^bscr ^cscr     ! Surface Coordinate Angles [radians]
lcl num ^pMx  ^pMy  ^pMz      ! pMon components
lcl num ^xMx  ^xMy  ^xMz      ! xMon components
lcl num ^yMx  ^yMy  ^yMz      ! yMon components
lcl num ^zMx  ^zMy  ^zMz      ! zMon components
lcl num ^lMr                  ! Normalizing Radius
lcl num ^L_LocalXaxis ^M_LocalXaxis ^N_LocalXaxis
lcl num ^L_LocalYaxis ^M_LocalYaxis ^N_LocalYaxis
lcl num ^L_LocalZaxis ^M_LocalZaxis ^N_LocalZaxis
LCL NUM ^ade_local ^bde_local ^cde_local
LCL NUM ^ind_current  ^ind_previous  ^ind_delta
LCL NUM ^lastsurf
LCL NUM ^Num_real_surfaces
LCL NUM ^iRealElt
LCL STR ^shape ^apestr
LCL NUM ^cir    ^adx    ^ady    ^rex    ^rey
LCL NUM ^cirobs ^adxobs ^adyobs ^rexobs ^reyobs
lcl num ^dummyfpa ^exitpupil
lcl num ^L_ygrid ^M_ygrid ^N_ygrid
lcl num ^L_xgrid ^M_xgrid ^N_xgrid
lcl num ^cuy
lcl num ^xobs_scale
lcl str ^outputfile

rfd 1 1 1 1 'macosfile.in'


!
! CONSTANTS
!
^zero ==  0.000000000e+00
^infinity ==  1.000000000e+20
^pi == 2.0*ASINF(1.0)
!
!
! DEFAULT MACOS CONSTANTS
!
^ext_coef    == ^zero
^flux        == 1.000000000e+00
^gridtype    == 1
^obscuration == ^zero
^ngridpts    == 65
^prop_type   ==  1
^n_ecoord    == 6   ! new value on 9/17/2013
!
!	READ IN CODE V PARAMETERS
!
! 9/17/2013.  Assume that the user enters the data manually.
!        IN CV2MACOS [GLOBAL SURFACE #]  [ZOOM POSITION] [FIELD NUMBER]  [WAVELENGTH NUMBER]

^global_sur == #1
^zoom_pos   == #2
^field_pos  == #3
^wave_pos   == #4
^outputfile == #5

!


!
! 9/17/2013 JMR. Skip the interactive reads.
goto skipread
   ver all no
   wri""
   wri"Enter global surface number"
   rea ^global_sur
   wri""
   wri"Enter zoom position"
   rea ^zoom_pos
   wri""
   wri"Enter field position"
   rea ^field_pos
   wri""
   wri"Enter Code V wavelength position"
   rea ^wave_pos
   wri""
   wri Q"Code V dimension is 'c'" (dim)
   wri""
lbl skipread



out t ^outputfile	!	Write output to screen and default file macosfile.in
!                               Gets placed by default into local directory.
!
!	 CHIEF RAY direction @object surface
!
^obj_index == (ind so z^zoom_pos w^wave_pos)
!
! DIRECTION COSINES OF CHIEF RAY RELATIVE TO GLOBAL REFERENCE SURFACE.
^l_chief ==(l r1 so w^wave_pos g^global_sur f^field_pos z^zoom_pos)/absf(^obj_index)
^m_chief ==(m r1 so w^wave_pos g^global_sur f^field_pos z^zoom_pos)/absf(^obj_index)
^n_chief ==(n r1 so w^wave_pos g^global_sur f^field_pos z^zoom_pos)/absf(^obj_index)
!
! COORDINATES OF SURFACE 1 RELATIVE TO GLOBAL REFERENCE SURFACE
^x_s1 ==(x r1 s1 w^wave_pos g^global_sur f^field_pos z^zoom_pos)
^y_s1 ==(y r1 s1 w^wave_pos g^global_sur f^field_pos z^zoom_pos)
^z_s1 ==(z r1 s1 w^wave_pos g^global_sur f^field_pos z^zoom_pos)
!

!	FOR 'INFINITE' CONJUGATE (defined as |object distance| >= 1e10 units)
!
if (absf((thi so z^zoom_pos)) >= (1.000e10))
!
! 9/17/13: hard-code an infinite object to a distance 1e22
	^z_source == 1e22
	^aperture ==(epd)
!
!	- Locate CR 100 units before s1.
!
	^x_chief ==(^x_s1-(100*^l_chief))
	^y_chief ==(^y_s1-(100*^m_chief))
	^z_chief ==(^z_s1-(100*^n_chief))
els
!	FOR 'FINITE' CONJUGATE (defined as |object distance| < 1e10 units)
!
	^aperture == absf(2*(nao))
!
	^x_so ==(x r1 so w^wave_pos g^global_sur f^field_pos z^zoom_pos)
	^y_so ==(y r1 so w^wave_pos g^global_sur f^field_pos z^zoom_pos)
	^z_so ==(z r1 so w^wave_pos g^global_sur f^field_pos z^zoom_pos)
!
!	- ChfRayPos halfway between object and s1.
!
	if (thi so z^zoom_pos) > 0		! REAL OBJECT
		^z_source == -((thi so z^zoom_pos)/2)
		^x_chief ==  ((^x_so+^x_s1)/2)
		^y_chief ==  ((^y_so+^x_s1)/2)
		^z_chief ==  ((^z_so+^x_s1)/2)
	els if (thi so z^zoom_pos) < 0		! VIRTURAL OBJECT
		^z_source == -(3*(thi so z^zoom_pos)/2)
		^x_chief == -((^x_so+^x_s1)/2)
		^y_chief == -((^y_so+^x_s1)/2)
		^z_chief == -((^z_so+^x_s1)/2)
	els
		wri""
		wri"Cannot have zero object distances.  Increment thi so"
		wri"infinitesimally as an approximation so that rays travel"
		wri"sequentially."
		wri""
	end if
end if  ! END OF FINITE- VERSUS INFINITE-CONJUGATE CHECK IF LOOP.

!
^format4 =="ChfRayDir= '2e.15e' '2e.15e' '2e.15e'"
^format5 =="ChfRayPos= '2e.15e' '2e.15e' '2e.15e'"
!
wri Q^format4 ^l_chief ^m_chief ^n_chief
wri Q^format5 ^x_chief ^y_chief ^z_chief
!


!  WRITE OTHER INITIAL PARAMETERS
!
!   Next, convert CODE V wavelength which is in nanometers, to System Dimensions

^wavelength ==(wl w^wave_pos)
if (dim) = 'I'                                       ! Inches
	^wavelength == ^wavelength/2.54*1.000000000e-07
els if (dim) = 'C'                                   ! Centimeters
	^wavelength == ^wavelength*1.000000000e-07
els if (dim) = 'M'                                   ! Millimeters
	^wavelength == ^wavelength*1.000000000e-06
els
      wri""
      wri"  *** Warning: Wavelength units not converted from nm! ***"
      wri""
end if
!
^format6  ==" zSource=  '2e.15e'"
^format7  =="  IndRef=  '2e.15e'"
^format8  =="  Extinc=  '2e.15e'"
^format9  ==" Wavelen=  '2e.15e'"
^format10 =="    Flux=  '2e.15e'"
^format11 =="GridType=    '2d'"
^format12 =="Aperture=  '2e.15e'"
^format13 =="Obscratn=  '2e.15e'"
^format14 =="nGridpts=  '3d'"
^format15 =="   xGrid=  '2e.15e' '2e.15e' '2e.15e'"
^format16 =="   yGrid=  '2e.15e' '2e.15e' '2e.15e'"
^format17 =="    nElt=  '3d'"
!
wri Q^format6 ^z_source
wri Q^format7 ^obj_index
wri Q^format8 ^ext_coef
wri Q^format9 ^wavelength
wri Q^format10 ^flux
if ^gridtype=1
	wri "GridType=   Circular"
els
	wri Q^format11 ^gridtype
end if
wri Q^format12 ^aperture
wri Q^format13 ^obscuration
wri Q^format14 ^ngridpts

! Sept 2013. The next commands find xGrid and yGrid, the direction cosines of the object x axis and y axis.
! We temporarily insert a dummy surface after the object surface and parallel to it, to find these axes.
ins s1
dar s1
! Rotate the dummy surface by 90 degrees in Y and find direction cosines. This will be Ygrid .
      ade s1 90
      bde s1 0
	^L_yGrid == (lsc s1 g^global_sur z^zoom_pos)
	^M_yGrid == (msc s1 g^global_sur z^zoom_pos)
	^N_yGrid == (nsc s1 g^global_sur z^zoom_pos)

! Rotate the dummy surface by 90 degrees in X and find direction cosines. This will be the Xgrid
      ade s1 0
      bde s1 90
	^L_xGrid == (lsc s1 g^global_sur z^zoom_pos)
	^M_xGrid == (msc s1 g^global_sur z^zoom_pos)
	^N_xGrid == (nsc s1 g^global_sur z^zoom_pos)

! Delete the temporary dummy surface.
del s1

wri Q^format15 ^L_xGrid ^M_xGrid ^N_xGrid    ! Sep 2013. xgrid.  Direction cosines of object X axis.
wri Q^format16 ^L_yGrid ^M_yGrid ^N_yGrid    ! Sep 2013. ygrid.  Direction cosines of object X axis.



! New on 9/17/2013: Because NElt is written at the start of the printout,
! and because we are now suppressing the printout of dummy surfaces, we need
! new commands to count the number of surfaces near the start,
! so that nElt (format17) can be written out.  NElt is no longer (num s).
! nElt does include the image surface.

^Num_real_surfaces == 0
for ^s 1 (num s)
  ^lastsurf == (num s)
  ^ind_current == (ind s^s)
  ^ind_previous == (ind s^s-1)
  ^ind_delta == ^ind_current-^ind_previous

  if ((^s < ^lastsurf) and (^ind_delta <> 0))
     ^num_real_surfaces == ^num_real_surfaces+1
  end if
end for

! Sept 2013. The above loop did not include the image surface, exit pupil, or dummy imager surface,
! so we get the final number of real surfaces by incrementing 3.

^num_real_surfaces ==  ^num_real_surfaces+3

wri Q^format17 ^num_real_surfaces

! ------------------------------------------------------------------------------------------------------------
wri""
!
!  FORMAT SURFACE VARIABLES
!
!^format1 =="'3d'  '2e.15e'  '2e.15e'  '2e.15e' '2e.15e'  '2e.15e'  '2e.15e'"
^format18 =="    iElt=  '3d'"
^format19 ==" EltName= surface_'d'"
^format19a ==" EltName= '32c'"
^format20 ==" EltType=  '3d'"
^format21 =="   KrElt=  '2e.15e'"
^format21a =="  KrElt=  '2e.15e'"
^format22 =="   KcElt=  '2e.15e'"
^format22a =="AsphCoef=  '2e.15e' '2e.15e' '2e.15e' '2e.15e'"
^format22b =="   KcElt=  '2e.15e'"
^format23 =="  psiElt=  '2e.15e' '2e.15e' '2e.15e'"
^format24 =="  VptElt=  '2e.15e' '2e.15e' '2e.15e'"
^format25 =="  RptElt=  '2e.15e' '2e.15e' '2e.15e'"
^format26 =="  IndRef=  '2e.15e'"
^format27 =="  Extinc=  '2e.15e'"
^format28 =="    zElt=  '2e.15e'"
^format29 =="PropType=    '1d'"
^format30 ==" nECoord=   '2d'"
^format31 =="   ApVec=  '2e.15e' '2e.15e' '2e.15e'"
^format32 =="   ApVec=  '2e.15e' '2e.15e' '2e.15e' '2e.15e'"

!  Zernike variables
^format33 =="ZernCoef=  '2e.15e' '2e.15e' '2e.15e' '2e.15e' '2e.15e' '2e.15e'"
^format34 =="           '2e.15e' '2e.15e' '2e.15e' '2e.15e' '2e.15e' '2e.15e'"
^format35 =="           '2e.15e' '2e.15e' '2e.15e'"
^format36 =="    pMon=  '2e.15e' '2e.15e' '2e.15e'"
^format37 =="    xMon=  '2e.15e' '2e.15e' '2e.15e'"
^format38 =="    yMon=  '2e.15e' '2e.15e' '2e.15e'"
^format39 =="    zMon=  '2e.15e' '2e.15e' '2e.15e'"
^format40 =="    lMon=  '2e.15e'"
^format41 == " '5c' '3e.15e' '3e.15e' '3e.15e' '3e.15e' '3e.15e' '3e.15e' "
!

! ----------------------------------------------------------------------------------------------
! LOOP THROUGH SURFACES AND WRITE OUT DATA FOR EACH SURFACE.
^iRealElt == 0
for ^s 1 (num s)

  ! New on 9/17/2013. If the surface is not the image surface, or I-1 or I-2, check if it is a dummy surface by computing delta index.
  ! If it is, bypass all surface calculations and do not print out the surface data.
  ! Skip directly to label "label_100".
  ! This would bypass a cemented interface with the same glass on both sides which may or may not be
  ! desireable but this can be addressed later if needed.

  ^lastsurf  == (num s)
  ^exitpupil == (num s)-1
  ^dummyfpa  == (num s)-2
  ^ind_current == (ind s^s)
  ^ind_previous == (ind s^s-1)
  ^ind_delta == ^ind_current-^ind_previous

  if ((^s < ^dummyfpa) and (^ind_delta = 0))
     goto label_100
  end if

! If not a dummy surface, define the real-element number of the surface.
  ^iRealElt == ^iRealElt+1

!
! CHECK IF IT IS A FLAT SURFACE.
^a_flat_surf == (absf((rdy s^s z^zoom_pos))>=^infinity)or((rdy s^s z^zoom_pos)=0)
^current_n  == ((ind s^s z^zoom_pos w^wave_pos))


! New on 1/25/2014:  For the +1 or -1 scaling of xObs, check of the curvature of the surface is positive/flat, or negative.
! We have determined that if curvature is negative, we do not scale (i.e. we scale xObs by +1).
! If curvature is 0 or positive, we scale xObs by -1.
if ((cuy s^s) < 0 )
   ^xobs_scale == 1
els
   ^xobs_scale == -1
end if


! New on Sept 30 2013.  Special handling of surfaces I-2 and I-1 and I which are hard-coded in CODE V model
! to be the dummy FPA and the exit pupil respectively.  Store data appropriate to these surfaces and then
! bypass the surface shape check commands.

if (^s = ^dummyfpa)
   ^elt_type == 4
   goto skip_surfaceshape_check
end if

if (^s = ^exitpupil)
   ^elt_type == 4
   goto skip_surfaceshape_check
end if


! Check surface shape type.  Separate IF branches for mirrors and non-mirrors.  ! in progress, sep 25 2013
! MIRRORS:
if (rmd s^s z^zoom_pos)='REFL'			! mirror
	if (typ sur s^s)='SPH'
		if (^a_flat_surf)
			^elt_type == 2		! flat reflector
		els
			^elt_type == 1		! conic relector
		end if
	els if (typ sur s^s)='CON'
		^elt_type == 1			! conic relector
	els if ((typ sur s^s)='ASP')or((typ sur s^s)='YTO')  ! aspheric reflector or
		^elt_type == 12				     ! y-toroid set to asphere
		wri""
		wri"ASPHERIC COEFFICIENTS FOR THE NEXT SURFACE ARE ONLY LISTED"
		wri"TO 10th ORDER 'D' TERM."
		wri""
		if (rdy s^s z^zoom_pos)>= 0
			^a_sur == (a s^s z^zoom_pos)
			^b_sur == (b s^s z^zoom_pos)
			^c_sur == (c s^s z^zoom_pos)
			^d_sur == (d s^s z^zoom_pos)
		els
			^a_sur == -(a s^s z^zoom_pos)
			^b_sur == -(b s^s z^zoom_pos)
			^c_sur == -(c s^s z^zoom_pos)
			^d_sur == -(d s^s z^zoom_pos)
		end if
      els if (typ sur s^s) = 'SPS ZRN'           ! *** Zernike reflector ***
                ^elt_type == 14
      els
	wri""
	wri"This macro does not incorporate this reflective element type."
	wri"Surface data not included here."
	wri""
	goto label_100

	end if
!
!     End of if-branch for checking shapes of reflective surfaces.  Next: refractive.
!
els if (rmd s^s z^zoom_pos)='REFR'	! refractive surface
	^previous_n == (ind s^s-1 z^zoom_pos w^wave_pos)
	^an_index_match == (^previous_n=^current_n)
!
	if (typ sur s^s)='SPH'
		if (^s=(num s))and(^a_flat_surf)
			^elt_type == 3	 ! Focal plane (if the image plane is curved
		els if (^an_index_match) !   it will not be defined as a focal plane.)
			^elt_type == 4	! reference surface
		els
			^elt_type == 8	! conic refractor
		end if
	els if (typ sur s^s)='CON'
		if (^an_index_match)
			^elt_type == 4	! reference surface
		els
			^elt_type == 8	! conic refractor   *** Why was this commented out? ***
		end if
	els if ((typ sur s^s)='ASP')or((typ sur s^s)='YTO') ! aspheric refractor or
		^elt_type == 20				    ! y-toroid set to asphere
		wri""
		wri"ASPHERIC COEFFICIENTS FOR THE NEXT SURFACE ARE ONLY LISTED"
		wri"TO 10th ORDER 'D' TERM."
		wri""
		if (rdy s^s z^zoom_pos)>= 0
			^a_sur == (a s^s z^zoom_pos)
			^b_sur == (b s^s z^zoom_pos)
			^c_sur == (c s^s z^zoom_pos)
			^d_sur == (d s^s z^zoom_pos)
		els
			^a_sur == -(a s^s z^zoom_pos)
			^b_sur == -(b s^s z^zoom_pos)
			^c_sur == -(c s^s z^zoom_pos)
			^d_sur == -(d s^s z^zoom_pos)
		end if
      els if (typ sur s^s) = 'SPS ZRN'              ! *** Zernike refractor ***
                ^elt_type == 21
      els

	     wri""
	     wri"This macro does not incorporate this refractive element type."
	     wri"Surface data not included here."
	     wri""
!
	     goto label_100
!
	end if
els
	wri""
	wri"This macro does not incorporate this element type."
	wri"Surface data not included here."
	wri""
!
	goto label_100
!
end if    ! END OF CHECKING SURFACE SHAPE TYPE

lbl skip_surfaceshape_check

!
!  Calculate asphericity and base radius (kr_elt)
!
if (typ sur s^s) = 'SPH'
	^conic_const == 0.000
	if (^a_flat_surf)
		^Kr_elt == -^infinity
	els
		if (rdy s^s z^zoom_pos) >= 0
			^Kr_elt == -(rdy s^s z^zoom_pos)
		els
			^Kr_elt == (rdy s^s z^zoom_pos)
		end if
	end if

els if ((typ sur s^s)='ASP')or((typ sur s^s)='CON')or((typ sur s^s)='YTO'or((typ sur s^s)='SPS ZRN'))
	^conic_const == (k s^s z^zoom_pos)
	if ^conic_const > 0		! oblate ellipsoid
		if (^a_flat_surf)
			^Kr_elt == -^infinity
		els
			if (rdy s^s z^zoom_pos) >= 0
				^Kr_elt == -(rdy s^s z^zoom_pos)
			els
				^Kr_elt == (rdy s^s z^zoom_pos)
			end if
			wri""
			wri"Verify fElt, eElt for the following oblate ellipsoid surface."
			wri""
		end if
	els
		if (^a_flat_surf)
			^Kr_elt == -^infinity
		els
			if (rdy s^s z^zoom_pos) >= 0
				^Kr_elt == -(rdy s^s z^zoom_pos)
			els
				^Kr_elt == (rdy s^s z^zoom_pos)
			end if
		end if
	end if
els

   wri""
   wri"Warning: Unknown surface type.  Kr, Kc not calculated for this surface."
   wri"Kr, Kc set to 0.0 by default."
   wri""
   ^Kr_elt == 0.0
   ^conic_const== 0.0
end if


! Additional commants for surface type YTO
if (typ sur s^s)='YTO'
		wri""
		wri"Y-toroid has been modelled as an aspheric surface."
		wri"Verify/correct EltType and other data for the following surface."
		wri""
end if
!

! GLOBAL SURFACE COORDINATES OF SURFACE VERTEX.
	^x_sur == (xsc s^s g^global_sur z^zoom_pos)
	^y_sur == (ysc s^s g^global_sur z^zoom_pos)
	^z_sur == (zsc s^s g^global_sur z^zoom_pos)
	^l_sur == (lsc s^s g^global_sur z^zoom_pos)
	^m_sur == (msc s^s g^global_sur z^zoom_pos)
	^n_sur == (nsc s^s g^global_sur z^zoom_pos)

! 9/17/2013: GLOBAL COORDINATES OF PIVOT POINT (RpElt).
! Assume it is always the intersection with ray R1 F1 Z1.
! This means that for Macos creation of different field angles,
! F1 Z1 must be the same, for consistency.
      ^x_RptElt == (x r1 f1 s^s g^global_sur z1)
      ^y_RptElt == (y r1 f1 s^s g^global_sur z1)
      ^z_RptElt == (z r1 f1 s^s g^global_sur z1)
!
! Write out the current number of real surfaces, excluding dummy surfaces.
	wri Q^format18 ^iRealElt

!                         Write Surface Label (commented out writing "Surface_#")
!      if  ((sll s^s)='')
!          wri Q^format19 ^s
!      els
          ^slabel == (sll s^s)
          wri Q^format19a ^slabel
!      end if
!

! Write out text that indicates the surface shape and element type.

! New Sept 2013: Special handling of surfaces I-2 and I-1 and I, all of which are non-conics.
      if (^s = ^dummyfpa)
            ^cuy == (cuy s^s)
            if (^cuy = 0)
               ^kr_elt == -^infinity
            els
               ^kr_elt == -(rdy s^s)
            end if
            wri "Element= Return"
            wri "Surface= Flat"
            wri q"KrElt= '2e.15e' " ^kr_elt
            wri q"KcElt= '2e.15e'" 0
            goto skipwriteshape
      end if

      if (^s = ^exitpupil)
            ^cuy == (cuy s^s)
            if (^cuy = 0)
               ^kr_elt == -^infinity
            els
               ^kr_elt == -(rdy s^s)
            end if
            wri "Element= Return"
            wri "Surface= Conic"
            wri q"KrElt= '2e.15e' " ^kr_elt
            wri q"KcElt= '2e.15e'" 0
            goto skipwriteshape
      end if


      if (^s = ^lastsurf)
            ^cuy == (cuy s^s)
            if (^cuy = 0)
               ^kr_elt == -^infinity
            els
               ^kr_elt == -(rdy s^s)
            end if
            wri "Element= FocalPlane"
            wri "Surface= Flat"
            wri q"KrElt= '2e.15e' " ^kr_elt
            wri q"KcElt= '2e.15e'" 0
            goto skipwriteshape
      end if



	if ^elt_type = 1
		wri" Element= Reflector"
		wri" Surface= Conic"

	els if ^elt_type = 2
		wri" Element= Reflector"
		wri" Surface= Flat"

	els if ^elt_type = 3
		wri" Element= FocalPlane"
		wri" Surface= Flat"

	els if ^elt_type = 4
		wri" Element= Reference"
		wri" Surface= Conic"

	els if ^elt_type = 8
		wri" Element= Refractor"
		wri" Surface= Conic"

      els if ^elt_type = 14             ! added Zernike Reflector
                wri" Element= Reflector"
                wri" Surface= Zernike"

      els if ^elt_type = 21             ! added Zernike Refractor (not tested)
                wri" Element= Refractor"
                wri" Surface= Zernike"

	els
		wri Q^format20 ^elt_type    ! y toroid refractor
	end if
!
	wri Q^format21 ^Kr_elt
	wri Q^format22 ^conic_const
!
	if (^elt_type = 12)OR(^elt_type = 20)
		wri Q^format22a ^a_sur ^b_sur ^c_sur ^d_sur
	end if

      lbl skipwriteshape
!
! --------------- Write Zernike parameters to 45th term ----------------------
!
        if (^elt_type = 14)OR(^elt_type = 21)
		if (rdy s^s z^zoom_pos)>= 0
                      for ^n 1 45
                          ^m == ^n+1
                          ^z(^n) == (sco s^s z^zoom_pos c^m)
                      end for
		els
!  Should coefficients go negative @ convex surfaces, as implemented below ?
                      for ^n 1 45
                          ^m == ^n+1
                          ^z(^n) == -(sco s^s z^zoom_pos c^m)
                      end for
		end if
!                      ***** Currently using VptElt for pMon *****
!                      This probably does not accommodate off-axis type optics
!               ^pMx ==
!               ^pMy ==
!               ^pMz ==
                ^ascr== (asc s^s g^global_sur z^zoom_pos)*^pi/180.0
                ^bscr== (bsc s^s g^global_sur z^zoom_pos)*^pi/180.0
                ^cscr== (csc s^s g^global_sur z^zoom_pos)*^pi/180.0
!                ^xMx == COSF(^cscr)*COSF(^bscr)
!                ^xMy == SINF(^cscr)*COSF(^ascr)-SINF(^ascr)*COSF(^cscr)*SINF(^bscr)
!                ^xMz == SINF(^cscr)*SINF(^ascr)+COSF(^cscr)*SINF(^bscr)*COSF(^ascr)
!                ^yMx == -SINF(^cscr)*COSF(^bscr)
!                ^yMy == COSF(^cscr)*COSF(^ascr)+SINF(^cscr)*SINF(^bscr)*SINF(^ascr)
!                ^yMz == COSF(^cscr)*SINF(^ascr)+SINF(^cscr)*SINF(^bscr)*COSF(^ascr)
              ^yMx == -(COSF(^cscr)*COSF(^bscr))
              ^yMy == -(SINF(^cscr)*COSF(^ascr)-SINF(^ascr)*COSF(^cscr)*SINF(^bscr))
              ^yMz == -(SINF(^cscr)*SINF(^ascr)+COSF(^cscr)*SINF(^bscr)*COSF(^ascr))
              ^xMx == -SINF(^cscr)*COSF(^bscr)
              ^xMy == COSF(^cscr)*COSF(^ascr)+SINF(^cscr)*SINF(^bscr)*SINF(^ascr)
              ^xMz == -(COSF(^cscr)*SINF(^ascr)+SINF(^cscr)*SINF(^bscr)*COSF(^ascr))
!
!                         ***** Currently using psiElt for zMon *****
!               ^zMx ==
!               ^zMy ==
!               ^zMz ==
                ^lMr == (sco s^s z^zoom_pos c69)
                wri"ZernType= Noll"          ! Default to Code V type ordering
                wri Q^format33 ^z(1)  ^z(2)  ^z(3)  ^z(4)  ^z(5)  ^z(6)
                wri Q^format34 ^z(7)  ^z(8)  ^z(9)  ^z(10) ^z(11) ^z(12)
                wri Q^format34 ^z(13) ^z(14) ^z(15) ^z(16) ^z(17) ^z(18)
                wri Q^format34 ^z(19) ^z(20) ^z(21) ^z(22) ^z(23) ^z(24)
                wri Q^format34 ^z(25) ^z(26) ^z(27) ^z(28) ^z(29) ^z(30)
                wri Q^format34 ^z(31) ^z(32) ^z(33) ^z(34) ^z(35) ^z(36)
                wri Q^format34 ^z(37) ^z(38) ^z(39) ^z(40) ^z(41) ^z(42)
                wri Q^format35 ^z(43) ^z(44) ^z(45)
!        wri Q^format36 ^pMx   ^pMy   ^pMz
                wri Q^format36 ^x_sur ^y_sur ^z_sur
                wri Q^format37 ^xMx   ^xMy   ^xMz
                wri Q^format38 ^yMx   ^yMy   ^yMz
!        wri Q^format39 ^zMx   ^zMy   ^zMz
	        if (rdy s^s z^zoom_pos) >= 0
		     wri Q^format39 ^l_sur ^m_sur ^n_sur
	        els
                     wri Q^format39 -(^l_sur) -(^m_sur) -(^n_sur)
!						reverse psi for negative element
                end if
                wri Q^format40 ^lMr

        end if  ! end of if-branch for Zernikes.
! ----------------------------------------------------------------------------
	if (rdy s^s z^zoom_pos) >= 0
		wri Q^format23 ^l_sur ^m_sur ^n_sur    ! psiElt
	els
		wri Q^format23 -(^l_sur) -(^m_sur) -(^n_sur)   ! psiElt
!						reverse psi for negative element
	end if

	wri Q^format24 ^x_sur ^y_sur ^z_sur           ! parent vertex  VptElt
	wri Q^format25 ^x_RptElt ^y_RptElt ^z_RptElt  ! pivot point vertex RptElt (intersection with ray R1 F1).  New on 9/17/13
	wri Q^format26 absf(^current_n)
	wri Q^format27 ^ext_coef
!	wri"    nObs=    0"
!
!

! NEW ON 9/17/2013:  find the direction cosines of the x-y-z axes of the normal of the parent surface.
! We will consider these to be the axes directions of the local surface at point RptElt.
! These axes generally will not be the true surface normals and tangents but the hope it, it is close enough
! for sensitivity analysis.  In any case it is the best known way for automatic computation.
! The direction cosine of the X axis will be used for the apertures and obscurations also.
!
! Step 1: insert a dummy surface before surface ^s (the current surface) and make it DAR.
! This dummy surface becomes the new surface ^s, and the original surface number is ^s+1
      ins s^s

      slb s^s 'axes'
      dar s'axes'

! Step 2: Assign tilts to surface 'axes' to make the surface have the same orientation as surface s+1.
      ade s'axes' (ade s'axes'+1)
      bde s'axes' (bde s'axes'+1)
      cde s'axes' (cde s'axes'+1)

      ^ade_local == (ade s'axes')
      ^bde_local == (bde s'axes')
      ^cde_local == (cde s'axes')

! Step 3: Evaluate the direction cosines of the z axis (normal to dummy surface).
	^L_LocalZaxis == (lsc s'axes' g^global_sur z^zoom_pos)
	^M_LocalZaxis == (msc s'axes' g^global_sur z^zoom_pos)
	^N_LocalZaxis == (nsc s'axes' g^global_sur z^zoom_pos)

! Step 4: rotate the dummy surface by 90 degrees in Y and find direction cosines. This will be the Y axis.
      ade s'axes' ^ade_local+90
      bde s'axes' ^bde_local
	^L_LocalYaxis == (lsc s'axes' g^global_sur z^zoom_pos)
	^M_LocalYaxis == (msc s'axes' g^global_sur z^zoom_pos)
	^N_LocalYaxis == (nsc s'axes' g^global_sur z^zoom_pos)

! Step 5: rotate the dummy surface by 90 degrees in X and find direction cosines. This will be the X axis.
      ade s'axes' ^ade_local
      bde s'axes' ^bde_local+90
	^L_LocalXaxis == (lsc s'axes' g^global_sur z^zoom_pos)
	^M_LocalXaxis == (msc s'axes' g^global_sur z^zoom_pos)
	^N_LocalXaxis == (nsc s'axes' g^global_sur z^zoom_pos)

! Step 6: Now that we have the direciton cosines, delete the dummy surface.
     del s'axes'

! At this point we have direction cosines of a X, Y, and Z axis, which will be used in the next
! sections of text, applied to apertures and surfaces.

!---------------------------------------------------------------------------------------------------------------------
! 9/17/2013.  New commands to evaluate aperture data, easier than trying to understand and modify the original commands
! which had been commented out anyway.

! Determine shape of clear aperture.
out no
buf del b0
ca n
buf y
ape s^s clr
buf n
out yes
buf mov b0 i1 j1

buf fnd "APERTURE DATA"
^apestr == (buf.str b0 iC+1 j1)
^shape == substr(^apestr,1,3)

IF (^shape = 'CIR')
  ^Ape_type == 1
  ^cir == (cir s^s)
  ^adx == (adx s^s)
  ^ady == (ady s^s)
ELS IF (^shape = 'REX')
  ^ape_type == 2
  ^rex == (rex s^s)
  ^rey == (rey s^s)
  ^adx == (adx s^s)
  ^ady == (ady s^s)
ELS
   ^ape_type == 0
END IF

! -----------------------------------
! Determine shape of obscuration.
out no
buf del b0
ca n
buf y
ape s^s obs
buf n
out yes
buf mov b0 i1 j1

buf fnd "APERTURE DATA"
^apestr == (buf.str b0 iC+1 j1)
^shape == substr(^apestr,1,3)

IF (^shape = 'CIR')
  ^obs_type == 1
  ^cirobs == (cir obs s^s)
  ^adxobs == (adx obs s^s)
  ^adyobs == (ady obs s^s)
ELS IF (^shape = 'REX')
  ^obs_type == 2
  ^rexobs == (rex obs s^s)
  ^reyobs == (rey obs s^s)
  ^adxobs == (adx obs s^s)
  ^adyobs == (ady obs s^s)
ELS
  ^obs_type == 0
END IF
! ============================================ end of aperture determination -=--------------------------

! Now write out the aperture data, if any. ----------------------------------
! New on 1/25/2014: scale xObs by -1 if the surface curvature is 0 or positive. Scale by +1 if curvature is negative.
! The scale factor, ^xobs_scale, was computed near the top of the FOR loop through the surfaces.
! xObs is the direction cosine of the x axis of the aperture.

if (^ape_type = 1) ! (circular aperture)
   wri "   ApType = Circle"
   wri q"  ApVec = '2e.15e' '2e.15e' '2e.15e' " ^cir ^adx ^ady
   wri q"  xObs = '2e.15e' '2e.15e' '2e.15e' " ^L_LocalXaxis*^xobs_scale ^M_LocalXaxis*^xobs_scale ^N_LocalXaxis*^xobs_scale
end if

if (^ape_type = 2) ! (rectangular aperture)
   wri "   ApType = Rectangular"
   wri q"  ApVec = '2e.15e' '2e.15e' '2e.15e' '2e.15e' " ^adx-^rex ^adx+^rex ^ady-^rey ^ady+^rey
   wri q"  xObs = '2e.15e' '2e.15e' '2e.15e' " ^L_LocalXaxis*^xobs_scale ^M_LocalXaxis*^xobs_scale ^N_LocalXaxis*^xobs_scale
end if

! Now write out the obscuration data, if any. ----------------------------------
if (^obs_type = 0)
   wri "   nObs =   0"
end if

if (^obs_type = 1)
   wri "   nObs =   1"
   wri "   ObsType = Circle"
   wri q"  ObsVec = '2e.15e' '2e.15e' '2e.15e' " ^cirobs ^adxobs ^adyobs
end if

if (^obs_type = 2)
   wri "   nObs =   1"
   wri "   ObsType = Rectangular"
   wri q"  ObsVec = '2e.15e' '2e.15e' '2e.15e' '2e.15e' " ^adxobs-^rexobs ^adxobs+^rexobs ^adyobs-^reyobs ^adyobs+^reyobs
end if

! End of 9/17/2013 section for apertures and obscurations. ======================================================================

! Write Zelt
	wri Q^format28 -^Kr_elt   ! Zelt

! New Sept 2013: Prop Type.
	if (^s = ^exitpupil)
		wri "PropType= FarField"
      els
		wri"PropType=  Geometric"
	end if

	wri Q^format30 ^n_ecoord    ! necoord

! 6x6 matrix creation.
! Now write out the direction cosine data, found above, as a 6x6 matrix.
! Upper right and lower left 3x3 quadrants are zeros. The upper left and lower right quadrants
! have the x,y,z axis direction cosines arranged in columns.

      wri Q^format41 "TElt=" ^L_LocalXaxis ^L_LocalYaxis ^L_LocalZaxis 0             0             0
      wri Q^format41 "     " ^M_LocalXaxis ^M_LocalYaxis ^M_LocalZaxis 0             0             0
      wri Q^format41 "     " ^N_LocalXaxis ^N_LocalYaxis ^N_LocalZaxis 0             0             0
      wri Q^format41 "     " 0             0             0           ^L_LocalXaxis ^L_LocalYaxis ^L_LocalZaxis
      wri Q^format41 "     " 0             0             0           ^M_LocalXaxis ^M_LocalYaxis ^M_LocalZaxis
      wri Q^format41 "     " 0             0             0           ^N_LocalXaxis ^N_LocalYaxis ^N_LocalZaxis

      wri " "

! --- END OF 6x6 matrix creation.

!
!	wri Q^format1 ^s ^x_sur ^y_sur ^z_sur ^l_sur ^m_sur ^n_sur	! table
!
lbl label_100        !  Kick out to here for surface types not covered.
!
end for   ! END OF LOOP OVER SURFACES
!


!  CALCULATE Tout
!
!	This calculates Tout for MACOS.  Tout defines the image plane coordinate system
!	and path length, in global coordinates.  The path length, dL, is set to 1.
!
^num_sur == (num s)
!				! need to use (num s) since
!				! (typ dec s'i') doesn't work in conditional
if (typ dec s^num_sur)='DAR'	! THIS ELIMINATES ERROR MESSAGES FOR NO DDA.
  if ((ade si)<>0)or((bde si)<>0)or((cde si)<>0)
	ins si			! add surface to perform image plane tilts
	ade si-1 (ade si)	! new surface is now si-1
	bde si-1 (bde si)	! put image plane tilts on this surface
	cde si-1 (cde si)	! since s decenters preceed tilts
      ade si 0 ! new 10/1/13
      bde si 0 ! new 10/1/13
      cde si 0 ! new 10/1/13
  end if
end if
!			Evaluate image plane x-vector
!
xde si 0			! initialize image plane decenters to zero
yde si 0
zde si 0
!
^initial_x == (xsc si g^global_sur z^zoom_pos)	! determine origin
^initial_y == (ysc si g^global_sur z^zoom_pos)
^initial_z == (zsc si g^global_sur z^zoom_pos)
!
xde si 1		! displace image plane to calc. x-dir
!
^final_x == (xsc si g^global_sur z^zoom_pos)
^final_y == (ysc si g^global_sur z^zoom_pos)
^final_z == (zsc si g^global_sur z^zoom_pos)
!
!	Calculate direction cosines for image plane x-axis
^lsc_x == ^final_x - ^initial_x		! global l-dircosine
^msc_x == ^final_y - ^initial_y		! global m-dircosine
^nsc_x == ^final_z - ^initial_z		! global n-dircosine
!
xde si 0		! reinitialize x-decenter
!
!		Evaluate image plane y-vector
!
yde si 1		! displace image plane to calc. y-dir
!
^final_x == (xsc si g^global_sur z^zoom_pos)
^final_y == (ysc si g^global_sur z^zoom_pos)
^final_z == (zsc si g^global_sur z^zoom_pos)
!
!	Calculate direction cosines for image plane y-axis
^lsc_y == ^final_x - ^initial_x		! global l-dircosine
^msc_y == ^final_y - ^initial_y		! global m-dircosine
^nsc_y == ^final_z - ^initial_z		! global n-dircosine
!
!
^format2a== " nOutCord=    5"
^format2 == "     Tout= '2e.15e' '2e.15e' '2e.15e' '2e.15e' '2e.15e' '2e.15e' '2e.15e'"
^format3 == "           '2e.15e' '2e.15e' '2e.15e' '2e.15e' '2e.15e' '2e.15e' '2e.15e'"
!
wri Q^format2a
wri Q^format2 ^lsc_x ^msc_x ^nsc_x ^zero ^zero ^zero ^zero
wri Q^format3 ^lsc_y ^msc_y ^nsc_y ^zero ^zero ^zero ^zero
wri Q^format3 ^zero ^zero ^zero ^lsc_x ^msc_x ^nsc_x ^zero
wri Q^format3 ^zero ^zero ^zero ^lsc_y ^msc_y ^nsc_y ^zero
wri Q^format3 ^zero ^zero ^zero ^zero ^zero ^zero  1
wri""
out t		! close output file, output to screen only.
!
ver all yes

! 9/17/13  undo the y decenter of si
yde si 0
!res		! restore original lens file
